{"version":3,"sources":["App.js","index.js"],"names":["randBetween","min","max","Math","floor","random","palette","App","props","ref","React","createRef","numCubes","animations","raycaster","THREE","mouse","addedEvents","eventName","element","listener","handlers","push","this","indexOf","addEventListener","event","preventDefault","x","clientX","renderer","domElement","clientWidth","y","clientY","clientHeight","setFromCamera","camera","intersects","intersectObjects","scene","children","length","object","forEach","handler","color","geometry","material","opacity","side","transparent","cube","shouldInit","factor","origFactor","add","rotation","abs","position","z","background","window","innerWidth","innerHeight","setSize","appendChild","skyColor","groundColour","hLight","dLight","set","target","addCube","animate","anim","render","requestAnimationFrame","PureComponent","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.c47749be.chunk.js","sourcesContent":["import React, { PureComponent } from 'react';\nimport * as THREE from \"three\";\nimport './App.css';\n\nconst randBetween = (min, max) => {\n  return Math.floor(Math.random() * (max + 1 - min)) + min;\n}\n\nconst palette = [\n  'rgb(142, 164, 210)',\n  'rgb(98,121,184)',\n  'rgb(162, 207, 166)',\n  'rgb(73,111,93)',\n  'rgb(98,121,184)',\n  'rgb(76,159,112)',\n];\n\nconst randGreen = () => {\n\n  return new THREE.Color(palette[randBetween(0, palette.length - 1)]);\n  const r = randBetween(50, 100);\n  const g = randBetween(150, 180);\n  const b = randBetween(50, 100);\n  return new THREE.Color(`rgb(${r}, ${g}, ${b})`);\n}\nconst randRed = () => {\n  const r = randBetween(150, 180);\n  const g = randBetween(50, 100);\n  const b = randBetween(50, 100);\n  return new THREE.Color(`rgb(${r}, ${g}, ${b})`);\n}\n\nclass App extends PureComponent {\n\n  constructor(props) {\n    super(props);\n    this.ref = React.createRef();\n    this.numCubes = 0;\n    this.animations = [];\n    this.raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n    this.addedEvents = [];\n  }\n\n  addEventListener(eventName, element, listener) {\n    element.handlers = element.handlers || {};\n    element.handlers[eventName] = element.handlers[eventName] || [];\n    element.handlers[eventName].push(listener);\n\n    if (this.addedEvents.indexOf(eventName) === -1) {\n      this.addedEvents.push(eventName);\n      this.ref.addEventListener(eventName, (event) => {\n        event.preventDefault();\n\n        this.mouse.x = (event.clientX / this.renderer.domElement.clientWidth) * 2 - 1;\n        this.mouse.y = - (event.clientY / this.renderer.domElement.clientHeight) * 2 + 1;\n\n        this.raycaster.setFromCamera(this.mouse, this.camera);\n\n        const intersects = this.raycaster.intersectObjects(this.scene.children);\n\n        // run on all (should do this for the 'up' events)\n        //intersects.filter(inter => 'click' in inter.object).forEach(inter => inter.object.click());\n\n        // run just on the foremost \n        if (intersects.length > 0) {\n          if (intersects[0].object.handlers) {\n            intersects[0].object.handlers[eventName].forEach(handler => handler());\n          }\n        }\n      });\n    }\n  };\n\n  addCube(color) {\n    this.numCubes++;\n\n    // Cube shape\n    //const geometry = new THREE.SphereGeometry(0.5, 5, 5);\n    const geometry = new THREE.BoxGeometry();\n\n    // Colour\n    const material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color(color || randGreen()),\n      opacity: 0.8,\n      side: THREE.DoubleSide,\n      transparent: true\n    });\n\n    // Start off at a random rotation and position\n    const cube = new THREE.Mesh(geometry, material);\n    // Trigger initialisation\n    cube.shouldInit = true;\n    // Factor defines drift and spin speed\n    cube.factor = Math.random() * 0.04 + 0.01;\n\n    this.addEventListener('mousedown', cube, () => {\n      cube.origFactor = cube.factor;\n      cube.factor = -0.01;\n      //material.originalColor = material.color;\n      //material.color = new THREE.Color(0xCC3333);\n    });\n    /*\n    this.addEventListener('mouseup', cube, () => {\n      cube.factor = cube.origFactor;\n      //material.color = material.originalColor;\n    });\n    /*\n        this.addEventListener('mouseleave', cube, () => {\n          if (!material.originalColor) {\n            return;\n          }\n          cube.factor = cube.origFactor;\n          material.color = material.originalColor;\n          delete material.originalColor;\n        });\n        */\n\n    this.scene.add(cube);\n\n    // Animate the cube\n    const animate = () => {\n      // Rotate\n      cube.rotation.x -= 0.01 + Math.abs(cube.factor) / 4;\n      cube.rotation.y += 0.01 + Math.abs(cube.factor) / 4;\n      // Drift away from camera\n      cube.position.z -= cube.factor;\n\n      if (cube.position.z < -25) {\n        // init when cubes get too far away\n        cube.shouldInit = true;\n      }\n\n      if (cube.factor < 0 && cube.position.z > 5) {\n        // reverse direction if cube is coming towards us and gets too close\n        cube.factor = 0 - cube.factor;\n      }\n\n      if (cube.shouldInit) {\n        cube.position.x = randBetween(-5, 5) + Math.random();\n        cube.position.y = randBetween(-5, 5) + Math.random();\n        cube.position.z = randBetween(5, 20);\n        cube.rotation.x = Math.random();\n        cube.rotation.y = Math.random();\n        cube.shouldInit = false;\n      }\n    };\n    // Push to animation queue\n    this.animations.push(animate);\n  }\n\n  componentDidMount() {\n    // Create basic scene\n    this.scene = new THREE.Scene();\n    this.scene.background = new THREE.Color(new THREE.Color('rgb(178, 212, 199)'));\n    this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth - 10, window.innerHeight - 10);\n    this.ref.appendChild(this.renderer.domElement);\n\n    // Add lighting\n    const skyColor = new THREE.Color('rgb(197, 219, 237)');\n    const groundColour = new THREE.Color('rgb(58, 65, 95)');\n    const intensity = 1;\n    const hLight = new THREE.HemisphereLight(skyColor, groundColour, intensity);\n    this.scene.add(hLight);\n\n    const color = new THREE.Color('rgb(125, 147, 198)');\n    const dLight = new THREE.DirectionalLight(color, intensity);\n    dLight.position.set(0, 10, 0);\n    dLight.target.position.set(-5, 0, 0);\n    this.scene.add(dLight);\n    this.scene.add(dLight.target);\n\n    this.camera.position.z = 7;\n\n    // Maybe animate light here?\n\n    // Render some cubes\n    let numCubes = 50;\n    while (numCubes--) {\n      this.addCube();\n    }\n\n    // Start animating and rendering.\n    const animate = () => {\n      this.animations.forEach(anim => anim());\n      // Now there's only 1 render no matter how many things are being animated\n      this.renderer.render(this.scene, this.camera);\n      requestAnimationFrame(animate);\n    };\n    animate();\n  }\n\n  render() {\n    return (\n      <div ref={ref => this.ref = ref}></div>\n    );\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}